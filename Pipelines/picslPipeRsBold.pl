#!/usr/bin/perl -w

##
## sample usage:  perl convertToNifti.pl subjects.txt Dicom Nifti
##
##


# use module
use strict;
use warnings;
use Data::Dumper;
use Cwd 'realpath';
use Cwd;
use Cwd 'abs_path';
use File::Spec;
use File::Find;
use File::Basename;
use File::Path;
use Getopt::Long;

sub logCmd {
  my $cmd = shift;
  my $log = shift;

  print $log "$cmd\n";
  my $val = system($cmd);

  return $val;
}


my $bold  = "";     # bold nii file
my $boldinfo = "";  # bold json file
my $t1 = "";        # t1 image (brain masked)
my $t1mask = "";    # t1 brain mask
my $seg = "";
my @echomag = ();
my $echophase = "";
my $echodelta = 2.46;
my $dwell = 0.00003;
my $nodes = "";
my @transforms=();
my $out = "";
my $verbose;

my $FSL = $ENV{'FSLDIR'};
$FSL = "${FSL}/bin";
my $ANTS = $ENV{'ANTSPATH'};

my $here = abs_path($0);
my @parts = split("/", $here);

my $PICSL = "";
for ( my $i=1; $i<(scalar(@parts)-2); $i++ ) {
  $PICSL = "$PICSL"."/".$parts[$i];
}
$PICSL="$PICSL"."/Utilities/";


GetOptions ("bold=s"            => \$bold,        # string
            "bold-info=s"       => \$boldinfo,     # string
            "t1=s"              => \$t1,
            "t1-mask=s"         => \$t1mask,
            "t1-segmentation=s" => \$seg,
            "echo-mag=s"        => \@echomag,
            "echo-phase=s"      => \$echophase,
            "echo-delta=f"      => \$echodelta,
            "dwell-time=f"      => \$dwell,
            "nodes=s"           => \$nodes,
            "transform=s"       => \@transforms,
            "out=s"             => \$out,
            "verbose"           => \$verbose)     # flag
or die("Error in command line arguments\n");

# Echo back inputs
if ( $verbose ) {
  print( "picslPipeRsBold.pl called with:\n");
  print( "Bold:            $bold\n");
  print( "Bold-info:       $boldinfo\n");
  print( "T1:              $t1\n");
  print( "T1-Mask:         $t1mask\n");
  print ("T1-Segmentation: $seg\n");
  print( "Echo-mag:        @echomag\n");
  print( "Echo-phase:      $echophase\n");
  print( "Echo-delta:      $echodelta\n");
  print( "Dwell-time:      $dwell\n");
  print( "Nodes:           $nodes\n");
  print( "Transforms:      @transforms\n");
  print( "Output-prefix:   $out\n");
  print( "\nSystem settings:\n");
  print( "FSL:             $FSL\n");
  print( "ANTS:            $ANTS\n");
  print( "PICSL:           $PICSL\n\n");
}

# Check for all required files
# FIXME

if ( scalar(@ARGV) == 0) {
  print( "$0\n");
  print( "Required parameters:\n");
  print( "--output          Output diretrory and file prefix\n");
  print( "--bold            Resting-state BOLD image\n");
  print( "--bold-info       .json file generated by dcm2niix for the BOLD image\n");
  print( "--t1              Brain-masked T1 image\n");
  print( "--t1-mask         Brain mask for above T1 image\n");
  print ("--t1-segmentation 6 tissue segmentation of T1 image\n");
  print( "--echo-mag        Echo magnitude image/s\n");
  print( "--echo-phase      Echo phase image\n");
  print( "--nodes           Nodes for time-signal averaging (T1 or template space)\n");
  print( "\nOptional parameters:\n");
  print( "--transform       If nodes in template space, template to T1 transforms supplied here\n");
  print( "--echo-delta      Echo delta for magnitude images (default=$echodelta)\n");
  print( "--dwell-time      Dwell-time (default=$dwell)\n");
  print( "\nSystem settings:\n");
  print( "FSL:             $FSL\n");
  print( "ANTS:            $ANTS\n");
  print( "PICSL:           $PICSL\n\n");

  exit;
}

if ( ! -s "$bold") {
  die("No BOLD image\n");
}

open( my $log, '>', "${out}commands.log" );

my $cmdTest = "";

if ( ! -s "${out}echomag.nii.gz") {
  if ( scalar(@echomag) > 1 ) {
    $cmdTest = logCmd( "${ANTS}/AverageImages 3 ${out}echomag.nii.gz 0 @echomag", $log);
  }
  else {
    $cmdTest = logCmd( "cp $echomag[0] ${out}echomag.nii.gz", $log);
  }
}

if ( ! -s "${out}echomag_BrainExtractionBrain.nii.gz" ) {
  if ( $verbose ) {
    print $log "# Brain Extraction for fieldmap\n";
  }

  $cmdTest = logCmd("${ANTS}/antsBrainExtraction.sh -d 3 -a ${out}echomag.nii.gz -c 3,2,3,1 -e $t1 -m $t1mask -q 1 -o ${out}echomag_",$log);

  #FSL suggest a tight mask and suggests "erring on excluding brain voxels"
  $cmdTest = logCmd("${ANTS}/ImageMath 3 ${out}echomag_BrainExtractionMask.nii.gz ME ${out}echomag_BrainExtractionMask.nii.gz 2", $log);
  $cmdTest = logCmd("${ANTS}/ImageMath 3 ${out}echomag_BrainExtractionBrain.nii.gz m ${out}echomag.nii.gz ${out}echomag_BrainExtractionMask.nii.gz", $log);

}

# Create shift map
if ( ! -s "${out}shiftmap.nii.gz" ) {
  if ( $verbose ) {
    print $log "# Distortion Correction\n";
  }

  my $fsl1 = "${FSL}/fsl_prepare_fieldmap SIEMENS $echophase ${out}echomag_BrainExtractionBrain.nii.gz ${out}fieldmap_rads.nii.gz $echodelta";
  $cmdTest = logCmd($fsl1, $log);
  my $fsl2 = "${FSL}/fugue -i $bold --dwell=$dwell --loadfmap=${out}fieldmap_rads.nii.gz --saveshift=${out}shiftmap.nii.gz -u ${out}rsbold_corr.nii.gz --unwarpdir=y-";
  $cmdTest = logCmd($fsl2, $log);
  $cmdTest = logCmd("Rscript ${PICSL}/shiftToWarp.R ${out}shiftmap.nii.gz ${out}shift0Warp.nii.gz", $log);
}

# Motion correction
if ( ! -s "${out}mocoMOCOparams.csv" ) {
  if ( $verbose ) {
    print $log "# Motion Correction of BOLD\n";
  }

  $cmdTest = logCmd("${ANTS}/antsMotionCorr -d 3 -a ${out}rsbold_corr.nii.gz -o ${out}bold_mean.nii.gz", $log);

  my $outFlag = "";

  for ( my $i=0; $i<3; $i++ ) {
    if ( $i == 2 ) {
      $outFlag = "-w 1";
    }
    my $moco = "${ANTS}/antsMotionCorr -d 3 -u 1 -m MI[${out}bold_mean.nii.gz,${out}rsbold_corr.nii.gz,1,32,Regular,0.25] -t Rigid[0.2] -f 3x2x1 -s 2x1x0 -i 100x100x100 -v 1 -o [${out}moco, ${out}bold_warped.nii.gz, ${out}bold_mean.nii.gz]  --use-histogram-matching 0 $outFlag";
    $cmdTest = logCmd( $moco, $log );
  }
}

# Bold -> T1 mapping
if ( ! -s "${out}boldToT11Warp.nii.gz" ) {
  if ( $verbose ) {
    print $log "# BOLD to T1 mapping\n";
  }
  $cmdTest = logCmd("${ANTS}/ResampleImageBySpacing 3 $t1 ${out}t1_ref.nii.gz 2 2 2", $log);
  $cmdTest = logCmd("${ANTS}/ResampleImageBySpacing 3 $t1mask ${out}t1_ref_mask.nii.gz 2 2 2", $log);
  $cmdTest = logCmd("${ANTS}/ThresholdImage 3 ${out}t1_ref_mask.nii.gz ${out}t1_ref_mask.nii.gz 0.01 Inf", $log);
  $cmdTest = logCmd("${ANTS}/antsRegistration -d 3 -z 1 --winsorize-image-intensities [0.005, 0.995] -u 1 -x [${out}t1_ref_mask.nii.gz] -m MI[ ${out}t1_ref.nii.gz, ${out}bold_mean.nii.gz, 1, 32, Regular, 0.25] -c [1000x500x100, 1e-7,5 ] -f 3x2x1 -s 2x1x0mm -t Affine[0.1] -m MI[ ${out}t1_ref.nii.gz, ${out}bold_mean.nii.gz, 1, 32, Regular, 0.25] -c [50x50x20, 1e-7,5 ] -f 3x2x1 -s 2x1x0mm -t SyN[0.1] -o [${out}boldToT1, ${out}boldToT1Warped.nii.gz] -v 1", $log);

  $cmdTest = logCmd("${ANTS}/antsApplyTransforms -d 3 -i $seg -o ${out}seg.nii.gz -r ${out}bold_mean.nii.gz -t [${out}boldToT10GenericAffine.mat] -t ${out}boldToT11InverseWarp.nii.gz -n MultiLabel -v 1", $log);
}





# Slice timing to csv
if ( ! -s "${out}timing.csv" ) {
  $cmdTest = logCmd( "Rscript ${PICSL}/getJSONVariable.R $boldinfo SliceTiming ${out}timing.csv", $log);
}

# Combo 4D warp
if ( ! -s "${out}bold_prepped.nii.gz") {
  $cmdTest = logCmd("${ANTS}/PrintHeader $bold > ${out}boldheader.txt", $log);

  my $dimString = `cat ${out}boldheader.txt | grep \" dim\\[4\\]\"`;
  my $timeDim = (split("=",$dimString))[1];
  chomp($timeDim);

  my $spacingString = `cat ${out}boldheader.txt | grep \"pixdim\\[4\\]\"`;
  my $timeSpacing = (split("=",$spacingString))[1];
  chomp($timeSpacing);

  my $offsetString = `cat ${out}boldheader.txt | grep \"toffset\"`;
  my $timeOffset = (split("=",$offsetString))[1];
  chomp($timeOffset);

  $cmdTest = logCmd("Rscript ${PICSL}/spatialToTimeWarp.R ${out}shift0Warp.nii.gz $timeDim $timeSpacing $timeOffset ${out}shiftTimeWarp.nii.gz", $log);
  $cmdTest = logCmd("Rscript ${PICSL}/sliceTimingWarp.R $bold ${out}timing.csv ${out}sliceTimingWarp.nii.gz", $log);
  $cmdTest = logCmd("${ANTS}/antsApplyTransforms -d 4 -i $bold -o ${out}bold_prepped.nii.gz -r $bold -t ${out}sliceTimingWarp.nii.gz -t ${out}mocoWarp.nii.gz -t ${out}shift0Warp.nii.gz -v 1", $log);
  #-n HammingWindowedSinc
  $cmdTest = logCmd("${ANTS}/SmoothImage 4 ${out}bold_prepped.nii.gz 2x2x2x0 ${out}bold_prepped.nii.gz 1", $log);
}

if ( ! -s "${out}bold_nodes.nii.gz" ) {
  my $txString = "";

  foreach my $tx ( @transforms ) {
    $txString = $txString." -t $tx";
  }

  $cmdTest = logCmd("${ANTS}/antsApplyTransforms -d 3 -i $nodes -o ${out}bold_nodes.nii.gz -r ${out}bold_mean.nii.gz -t [${out}boldToT10GenericAffine.mat] -t ${out}boldToT11InverseWarp.nii.gz $txString -n MultiLabel -v 1", $log);


}

# Clean-up
$cmdTest = logCmd("rm ${out}shiftTimeWarp.nii.gz", $log);
$cmdTest = logCmd("rm ${out}sliceTimingWarp.nii.gz", $log);
